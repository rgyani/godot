#!/usr/bin/env python

Import("env")
Import("env_modules")

env_skia = env_modules.Clone()

# Thirdparty source files

thirdparty_obj = []

if env["builtin_skia"]:
    env_skia.disable_warnings()

    thirdparty_dir = "#thirdparty/skia/"
    thirdparty_sources = [
        "src/core/SkArenaAlloc.cpp",
        "src/core/SkCubicClipper.cpp",
        "src/core/SkEdgeClipper.cpp",
        "src/core/SkGeometry.cpp",
        "src/core/SkIDChangeListener.cpp",
        "src/core/SkLineClipper.cpp",
        "src/core/SkMalloc.cpp",
        "src/core/SkMath.cpp",
        "src/core/SkMatrix.cpp",
        "src/core/SkPath.cpp",
        "src/core/SkPathBuilder.cpp",
        "src/core/SkPathRef.cpp",
        "src/core/SkPoint.cpp",
        "src/core/SkRRect.cpp",
        "src/core/SkRect.cpp",
        "src/core/SkSemaphore.cpp",
        "src/core/SkThreadID.cpp",
        "src/pathops/SkAddIntersections.cpp",
        "src/pathops/SkDLineIntersection.cpp",
        "src/pathops/SkOpBuilder.cpp",
        "src/pathops/SkOpEdgeBuilder.cpp",
        "src/pathops/SkPathOpsCommon.cpp",
        "src/pathops/SkPathOpsDebug.cpp",
        "src/pathops/SkPathOpsRect.cpp",
        "src/pathops/SkPathOpsTypes.cpp",
        "src/pathops/SkDConicLineIntersection.cpp",
        "src/pathops/SkDQuadLineIntersection.cpp",
        "src/pathops/SkOpCoincidence.cpp",
        "src/pathops/SkOpSegment.cpp",
        "src/pathops/SkPathOpsConic.cpp",
        "src/pathops/SkPathOpsLine.cpp",
        "src/pathops/SkPathOpsSimplify.cpp",
        "src/pathops/SkPathOpsWinding.cpp",
        "src/pathops/SkDCubicLineIntersection.cpp",
        "src/pathops/SkIntersections.cpp",
        "src/pathops/SkOpContour.cpp",
        "src/pathops/SkOpSpan.cpp",
        "src/pathops/SkPathOpsCubic.cpp",
        "src/pathops/SkPathOpsOp.cpp",
        "src/pathops/SkPathOpsTSect.cpp",
        "src/pathops/SkPathWriter.cpp",
        "src/pathops/SkOpAngle.cpp",
        "src/pathops/SkOpCubicHull.cpp",
        "src/pathops/SkPathOpsCurve.cpp",
        "src/pathops/SkPathOpsQuad.cpp",
        "src/pathops/SkReduceOrder.cpp",
        "src/ports/SkMemory_malloc.cpp",
        "src/ports/SkDebug_android.cpp",
        "src/ports/SkDebug_stdio.cpp",
        "src/ports/SkDebug_win.cpp",
    ]
    thirdparty_sources = [thirdparty_dir + file for file in thirdparty_sources]

    env_skia.Append(
        CPPPATH=[
            "#thirdparty/skia/",
            "#thirdparty/skia/include",
        ]
    )
    env.Append(
        CPPPATH=[
            "#thirdparty/skia/",
        ]
    )
    env_skia.Append(CPPDEFINES=["SK_SUPPORT_GPU=0"])
    if env["target"] == "debug":
        env_skia.Append(CPPDEFINES=["SK_DEBUG"])
    else:
        env_skia.Append(CPPDEFINES=["SK_RELEASE"])

    lib = env_skia.add_library("skia_builtin", thirdparty_sources)
    thirdparty_obj += lib

    # Needs to be appended to arrive after libscene in the linker call,
    # but we don't want it to arrive *after* system libs, so manual hack
    # LIBS contains first SCons Library objects ("SCons.Node.FS.File object")
    # and then plain strings for system library. We insert between the two.
    inserted = False
    for idx, linklib in enumerate(env["LIBS"]):
        if isinstance(linklib, (str, bytes)):  # first system lib such as "X11", otherwise SCons lib object
            env["LIBS"].insert(idx, lib)
            inserted = True
            break
    if not inserted:
        env.Append(LIBS=[lib])


# Godot source files

module_obj = []

env_skia.add_source_files(module_obj, "*.cpp")
env.modules_sources += module_obj

# Needed to force rebuilding the module files when the thirdparty library is updated.
env.Depends(module_obj, thirdparty_obj)
